---
layout: post
title: MS SQL > Profiler and Events (logging queries, etc.)
---
## the case	
the question is, how to capture what's going on in the DB in the most detailed/useful manner

## toc
<!-- TOC -->

- [ON MS SQL](#on-ms-sql)
- [SQL TRACES](#sql-traces)
- [events](#events)
- [ARCHITECTURE OF SQL TRACES](#architecture-of-sql-traces)
- [plan cache](#plan-cache)
- [profiler](#profiler)
- [new trace](#new-trace)
- [TSQL Template](#tsql-template)
- [TQLDuration](#tqlduration)
- [extended events](#extended-events)
- [SQL > Export / Import table SSMS](#sql--export--import-table-ssms)
- [sources](#sources)

<!-- /TOC -->

## findings
### ON MS SQL
* On June 12th, 1988, Microsoft joined Ashton-Tate and Sybase to create a variant of Sybase SQL Server for IBM OS/2 (then developed jointly with Microsoft), which was released the following year.[1] 
* This was the first version of Microsoft SQL Server, and served as Microsoft's entry to the enterprise-level database market, competing against Oracle, IBM, Informix, Ingres and later, Sybase. 
* SQL Server 4.2 was shipped in 1992, bundled with OS/2 version 1.3, followed by version 4.21 for Windows NT, released alongside Windows NT 3.1. 
* SQL Server 6.0 was the first version designed for NT and did not include any direction from Sybase.

### SQL TRACES
* low-level
* server-side
* should not always be the first response to a performance problem
* use dynamic management objects, if possible
* event implementation in SQL server
* **benefit**
    * allows for real-time or offline analysis of event data through the use of a streaming rowset destination or file destination
* the basic logging technique for DB admins, pretty important it seems
* understanding how an application is actually using SQL server is critical when tuning query performance
* sometimes query execution plans are not cached, which makes workload analysis impossible without tracing
* now always possible to do query performance tuning from the plan cache
    * auto-parameterization

### events
* defines a known point in code execution 
* it fires only when
    * its point is reached
    * the event is enabled for capture by an active trace
* events provide specific information about the conditions for the event firing
    * standardized set of columns:
        * 10 global for session info
        * 56 additional w/ info specific to the event that is firing
* events are divided into categories
    * more than 20 cats
    * more than 180 events

### ARCHITECTURE OF SQL TRACES

![sql-trace-architecture]({{ site.url }}/assets/img000313.png)

* Components
    * sqltrace controller
        * central component managing all of the traces
        * provided a sync queue for event data
        * maintains a global event bitmap for tracking which events have been enabled 
    * event providers
        * generate data associated with events
        * events are disabled by default
    * events
    * I/O providers
        * final 
        * server-side file provided
        * client rowset provider for streaming data to a client app (like Profiler
    * external profiler application

### plan cache
* Whenever a query is run for the first time in SQL Server, it is compiled and a query plan is generated for the query. Every query requires a query plan before it is actually executed. This query plan is stored in the SQL Server query plan cache. This way when that query is run again, SQL Server doesn’t need to create another query plan; rather it uses the cached query plan which improved database performance.

### profiler
* ..."old and famous"
    * but already controversial
* also for devs
* to learn how the app uses DB during development and test cycles
* client app that simplifies the task of creating new traces and reading trace data
* uses the rowset provider to read event data generated by the server-side trace feature
* can create overhead that reduces the performance

### new trace
* File ➔ New Trace ➔ Connect to DB ➔ Select **blank** from template (remove the default **standard**)
* In Blank, All Events and All Columns are active
    * by default only w/ blank template

### TSQL Template
* used for debugging client applications
    * login
    * login
    * existing connection
    * RPC: Starting
    * SQL: BatchStarting
        * not performance diag
        * no cpu duration, read/write 

### TQL_Duration
* Captures all statements and groups them by duration
* Columns are organized differently, they are grouped / aggregated
* Longest events are bubbling up in the bottom
* See what resources are 
* can be used to identify slow queries
    * Events: 
        * RPC: Completed
        * SQL: BatchCompleted
    
### extended events
* Microsoft SQL Server 2014 or higher (not for pivotal)
* leightweight monitoring tool collecting data about inner operations of sql server
* leightweight
* extensive
* portable
    * carry your own events to the client ➔ deploy multiple times

### SQL > Export / Import table SSMS
* ueries that are created by the system (via toolkit) are stored in the BM, but queries created by end users are stored in the ED.

###  sources
* [Exporting Selected tables from a SQL Database](https://blogs.msdn.microsoft.com/tfssetup/2012/01/09/exporting-selected-tables-from-a-sql-database/)