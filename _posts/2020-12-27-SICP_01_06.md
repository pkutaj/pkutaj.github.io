---
layout: post
title: SICP 01 — On 3 dimensions of every language, and LISP in particular (primitives, combinations and abstractions)
categories: [cs]
---
## usecase
The doc's aim is to gloss over the three dimensions of LISP / Clojure as covered in the [SICP_01](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/):
* language primitives
* means of combinations (structures)
* means of abstractions (naming/functions)

Also, some notes will be added on the role of parenthesis in this language and then the musings on apply/eval definitions.

<!-- TOC -->

- [1. primitives](#1-primitives)
- [2. combinations](#2-combinations)
- [3. abstractions](#3-abstractions)
    - [3.1. def](#31-def)
    - [3.2. defn](#32-defn)
- [4. apply & eval](#4-apply--eval)
- [5. parenthetis in LISP](#5-parenthetis-in-lisp)
- [6. sources](#6-sources)

<!-- /TOC -->

### 1. primitives
* what is the list of primitives that cannot be futher disected ?
* the list of clojure primitives is pretty substantial

#NR | PRIMITIVE CAT | PRIMITIVE AREA
----|---------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.  | Literals      | Long: 7, hex 0xff, oct 017, base 2 2r1011, base 36 36rCRAZY BigInt: 7N Ratio: -22/7 Double: 2.78 -1.2e-5 BigDecimal: 4.2M
2.  | Arithmetic    | + - * / quot rem mod inc dec max min +' -' *' inc' dec'
3.  | Compare       | == < > <= >= compare
4.  | Bitwise       | bit-and bit-or bit-xor bit-not bit-flip bit-set bit-shift-right bit-shift-left bit-and-not bit-clear bit-test unsigned-bit-shift-right (see BigInteger for integers larger than Long)
5.  | Cast          | byte short int long float double bigdec bigint num rationalize biginteger
6.  | Test          | zero? pos? neg? even? odd? number? rational? integer? ratio? decimal? float? (1.9) double? int? nat-int? neg-int? pos-int?
7.  | Random        | rand rand-int
8.  | BigDecimal    | with-precision
9.  | Unchecked     | *unchecked-math* unchecked-add unchecked-dec unchecked-inc unchecked-multiply unchecked-negate unchecked-subtract


### 2. combinations
* what are the means of combinations in this language ?
* take primitive elements and put them together to create **combinations**
* usually you **apply** an operator to operands
* same as in other LISP languages, the essence is 
    * prefix notation
    * fully parenthetised
    
```clojure
(+ 3 (* 5 6) 8 2)
```
### 3. abstractions
* what are the means of ABSTRACTION ? 
* is it possible to abstract a combination and give it a simple name ?
* how do you take complicated things and "draw boxes around them" -> make primitive elements out them 

#### 3.1. def
* `def` in clojure

```clojure
> (def a 2)
#'user/a
6
> (+ a a 3)
7
``` 

* you identify a variable and give it a value (it can be a compound object)
* this — however — is not really powerful

#### 3.2. defn
* you want to name a general method, to name the general idea of — for example - multiplying somesomewhing with itself
* → squaring

![function_definition]({{ site.url }}/assets/img002399.jpg)

* the essence is that **I AM NAMING SOMETHING** and that something is the instruction

![same_thing]({{ site.url }}/assets/img002400.jpg)

* the key thing in LISP is that that you can't recognize the primitives that have been built-in the language, and that have been built-in by programmers

* the first and convenient method is just syntactic sugar (a convenient surface form for typing something) and should be removed

> This disdain for syntax is due partly to the flexibility of Lisp, which makes it easy to change surface syntax, and partly to the observation that many "convenient'' syntactic constructs, which make the language less uniform, end up causing more trouble than they are worth when programs become large and complex. In the words of Alan Perlis, "Syntactic sugar causes cancer of the semicolon.''

### 4. apply & eval
* when in REPL, you ask the interpreter to evaluate the application 
    * operator on
    * operands
* you apply function to objects (you combine)
* and you evaluate — you return the value of a selected expression / combination 
* if you just enter a string or an int, the evaluation is going to be identical - nothing was applied there

### 5. parenthetis in LISP
* different than in math
* you cannot leave out parenthesis
* you cannot put in extra parenthesis
* this means precisely **this is a combination** → with precise meahing _apply _ operator to operands
* each combination is a **tree**
* combinatino is away to write this 2D structure as a linear character strin

![combination_is_tree]({{ site.url }}/assets/img002398.jpg)

* in LISP, we are writing trees



### 6. sources
* [Clojure - Cheatsheet](https://clojure.org/api/cheatsheet)
* [Why Clojure?](https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html)
* [Naming And The Environment](http://www.sicpdistilled.com/section/1.1.2/)
* [Evaluating Combinations](http://www.sicpdistilled.com/section/1.1.3/)
